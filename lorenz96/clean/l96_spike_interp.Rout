
R version 4.0.2 (2020-06-22) -- "Taking Off Again"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> set.seed(1)
> library(mvtnorm)
> library(mcmc)
> library(invgamma)
> 
> make_tilde <- function(X, t) {
+     X_vec = c(1, X[1], X[2], X[3], X[4], X[1] ^ 2, X[2] ^ 2, X[3] ^ 2, X[4] ^ 2, X[1] * X[2], X[1] * X[3], X[1] * X[4],
+               X[2] * X[3], X[2] * X[4], X[3] * X[4], t, t ^ 2)
+     return(X_vec)
+ }
> # drifet function for Lorenz-63
> drift_fun <- function(X, t, B) {
+     #print(make_tilde(X,t))
+     tildeX = matrix(make_tilde(X, t), nrow = 17, ncol = 1)
+     B_mat = matrix(B, nrow = N.l96)
+     ans = B_mat %*% tildeX
+     return(ans)
+ }
> 
> drift_fun_true <- function(X, theta) {
+     ans = matrix(, nrow = N.l96, ncol = 1)
+     for (i in 0:(N.l96 - 1)) {
+         ans[i + 1, 1] = (X[(i + 1) %% N.l96 + 1] - X[(i - 2) %% N.l96 + 1]) * X[(i - 1) %% N.l96 + 1] - X[i + 1] + theta
+     }
+     return(ans)
+ }
> 
> ludfun <- function(state, gamma) {
+     # State is the vector storing the vectors of length 3*N + 12. The first 3*(N+1) terms are Xs. The next three terms are the parameters \sigma, \rho & 
+     # \beta. The remaining 6 terms are the \Sigma matrix. Definition of Sigma below shows how the symmetric matrix is constructed.
+ 
+     X_n = matrix(state[1:n.X], nrow = N.l96, ncol = N + 1)
+     B_vec = state[(n.X + 1):(n.X + n.theta)] # vector of \sigma, \rho and \beta    
+     B_mat = matrix(B_vec, nrow = N.l96)
+ 
+     X_t = X_n[, seq(2, N + 1, N / K)]
+ 
+     #######################################################################
+     p1 = (sum(dmvnorm(t(Y - X_t), sigma = R, log = TRUE)))
+     #- 0.5 * t(t(t(X_n[, 1])) - tau_o) %*% inv.lam_o %*% (t(t(X_n[, 1])) - tau_o))
+     ######################################################################
+     B_cov_gamma = gamma * (tau1 ^ 2) + (1 - gamma) * (tau0 ^ 2)
+     p2 = dmvnorm(B_vec, sigma = diag(B_cov_gamma), log = TRUE)
+     #p2 = (alpha1 - 1) * log(theta[1]) - theta[1] / beta1 + (alpha2 - 1) * log(theta[2]) - theta[2] / beta2 + (alpha3 - 1) * log(theta[3]) - theta[3] / beta3
+ 
+ 
+     f = mapply(drift_fun, X = split(X_n, rep(1:ncol(X_n), each = nrow(X_n))), t = del_t * (0:N), MoreArgs = list(B_vec))
+     #f = sapply(split(X_n, rep(1:ncol(X_n), each = nrow(X_n))), drift_fun, B_vec, list(1,2))
+     del_X = t(diff(t(X_n)))
+     beta_tmp = rowSums((del_X / del_t - f[, - (N + 1)]) ^ 2) * del_t / 2
+     p3 = -(a4 + N / 2) * sum(log(b4 + beta_tmp))
+ 
+     return(p1 + p2 + p3)
+ 
+ }
> 
> ludfun.X <- function(state, gamma, all) {
+     # State is the vector storing the vectors of length 3*N + 12. The first 3*(N+1) terms are Xs. The next three terms are the parameters \sigma, \rho & 
+     # \beta. The remaining 6 terms are the \Sigma matrix. Definition of Sigma below shows how the symmetric matrix is constructed.
+     all[1:n.X] = state
+     X_n = matrix(all[1:n.X], nrow = N.l96, ncol = N + 1)
+     B_vec = all[(n.X + 1):(n.X + n.theta)] # vector of \sigma, \rho and \beta    
+     B_mat = matrix(B_vec, nrow = N.l96)
+ 
+     # Extracting observed data
+     X_t = X_n[, seq(2, N + 1, N / K)]
+ 
+     #######################################################################
+     p1 = (sum(dmvnorm(t(Y - X_t), sigma = R, log = TRUE)))
+     #- 0.5 * t(t(t(X_n[, 1])) - tau_o) %*% inv.lam_o %*% (t(t(X_n[, 1])) - tau_o))
+     ######################################################################
+     B_cov_gamma = gamma * (tau1 ^ 2) + (1 - gamma) * (tau0 ^ 2)
+     p2 = dmvnorm(B_vec, sigma = diag(B_cov_gamma), log = TRUE)
+     #p2 = (-1 / 2) * sum((B_vec - mu) ^ 2) / sigma2
+ 
+     #f = mapply(drift_fun, X = split(X_n, rep(1:ncol(X_n), each = nrow(X_n))), t = del_t * (0:N), MoreArgs = list(B_vec))
+     f = mapply(drift_fun, X = split(X_n, rep(1:ncol(X_n), each = nrow(X_n))), t = del_t * (0:N), MoreArgs = list(B_vec))
+     #f = sapply(split(X_n, rep(1:ncol(X_n), each = nrow(X_n))), drift_fun, B_vec, list(1,2))
+     del_X = t(diff(t(X_n)))
+     beta_tmp = rowSums((del_X / del_t - f[, - (N + 1)]) ^ 2) * del_t / 2
+     p3 = -(a4 + N / 2) * sum(log(b4 + beta_tmp))
+ 
+     return(p1 + p2 + p3)
+ 
+ }
> 
> sample_gamma <- function(B_vec) {
+     gamma = numeric(length = n.theta)
+     for (i in 1:n.theta) {
+         prob = q[i] * dnorm(B_vec[i], sd = tau1) / (q[i] * dnorm(B_vec[i], sd = tau1) + (1 - q[i]) * dnorm(B_vec[i], sd = tau0))
+         gamma[i] = rbinom(1, 1, prob)
+     }
+     return(gamma)
+ }
> 
> MH.X <- function(init, n, scale, gamma, B_vec) {
+     chain = matrix(, nrow = n, ncol = n.X)
+     accept.prob = 0
+     for (i in 1:n) {
+         prop = sapply(init, function(t) rnorm(1, t, scale))
+         prop_ludf = c(prop, B_vec)
+         init_ludf = c(init, B_vec)
+         if (log(runif(1)) < (ludfun(prop_ludf, gamma) - ludfun(init_ludf, gamma))) {
+             init = prop
+             accept.prob = accept.prob + 1
+         }
+         chain[i,] = init
+     }
+     ans = list(chain, accept.prob / n)
+     return(ans)
+ }
> 
> MH.B <- function(index, init, n, scale, gamma, state) {
+     chain = numeric(length = n)
+     accept.prob = 0
+     prop_ludf = state
+     init_ludf = state
+     for (i in 1:n) {
+         prop = rnorm(1, init, scale)
+         prop_ludf[n.X + index] = prop
+         init_ludf[n.X + index] = init
+         if (log(runif(1)) < (ludfun(prop_ludf, gamma) - ludfun(init_ludf, gamma))) {
+             init = prop
+             accept.prob = accept.prob + 1
+         }
+         chain[i] = init
+     }
+     ans = list(chain, accept.prob / n)
+     return(ans)
+ }
> 
> linchpin <- function(n, init) {
+     X_avg = numeric(length = n.X)
+     param_mat = matrix(, nrow = n, ncol = 2 * n.theta + n.sigma)
+     
+     scale.B = scale
+ 
+     accept.prob = numeric(1 + n.theta)
+     state = init
+ 
+     for (i in 1:n) {
+         gamma = sample_gamma(init[(n.X + 1):(n.X + n.theta)])
+         param_mat[i, (n.theta + n.sigma + 1):(2 * n.theta + n.sigma)] = gamma
+ 
+         if (i %% (n / 5) == 0) {
+             print(i)
+             print(accept.prob[1]/i)
+             print(matrix(accept.prob[2:(n.theta + 1)] / i, nrow = N.l96))
+         }
+ 
+         all = init
+         chain = metrop(ludfun.X, initial = init[1:n.X], nbatch = 1, scale = scale.X, gamma = gamma, all = all)
+         accept.prob[1] = accept.prob[1] + chain$accept
+         state[1:n.X] = chain$batch
+ 
+ 
+         for (j in 1:n.theta) {
+ 
+             ans = MH.B(j, init[n.X + j], 1, scale.B[j], gamma, state)
+             accept.prob[j + 1] = accept.prob[j + 1] + ans[[2]]
+             state[n.X + j] = ans[[1]]
+         }
+ 
+         X_n = matrix(state[1:n.X], nrow = N.l96, ncol = N + 1)
+         theta = state[(n.X + 1):(n.X + n.theta)] # vector of \sigma, \rho and \beta 
+         X_avg = X_avg + state[1:n.X]
+         param_mat[i, 1:n.theta] = theta
+ 
+         Sigma = numeric(length = n.sigma)
+         f = mapply(drift_fun, X = split(X_n, rep(1:ncol(X_n), each = nrow(X_n))), t = del_t * (0:N), MoreArgs = list(theta))
+         del_X = t(diff(t(X_n)))
+         beta_tmp = rowSums((del_X / del_t - f[, - (N + 1)]) ^ 2) * del_t / 2
+         for (j in 1:n.sigma) {
+             Sigma[j] = rinvgamma(1, shape = N / 2 + a4, rate = b4 + beta_tmp[j])
+         }
+ 
+         param_mat[i, (n.theta + 1):(n.theta + n.sigma)] = Sigma
+         init = state
+     }
+     #print(accept.prob / n)
+     save.X = state[1:n.X]
+     X_avg = X_avg / n
+     final_output = list(param_mat, X_avg, save.X,accept.prob / n)
+     return(final_output)
+ }
> 
> 
> # Numerical method to sample from SDE
> euler_maruyama <- function(X0, del_t, N, theta, Sigma) {
+     X = matrix(, nrow = N.l96, ncol = N + 1)
+     X[, 1] = X0
+     for (i in 2:(N + 1))
+         X[, i] = X[, i - 1] + t(drift_fun_true(X[, i - 1], theta)) * del_t + rmvnorm(1, sigma = del_t * Sigma)
+     return(X)
+ }
> # X = euler_maruyama(c(1,1,1), 0.1, 20, c(1,2,3), diag(2,3))
> 
> 
> # hyper-parameters
> to = 0 # initial time
> tf = 10 # final time
> Nobs = 20 # no of observations (Y) per time step
> N.l96 = 4
> del_t = 0.01 # discrete approximation of dt
> a4 = 2
> b4 = .5
> tau1 = 10
> tau0 = 0.5
> 
> K = (tf - to) * Nobs # no of real life observations, i.e. size of Y
> N = (tf - to) / del_t # no of discretizations of the Lorenz-63, i.e. size of X
> burn_in = 5000 #/ del_t
> R = diag(.05, N.l96) # observational error
> inv_R = diag(1 / (0.05), N.l96)
> mu = 0
> sigma2 = 10
> mu_truth = c(rep(8, 4), as.numeric(diag(rep(-1, 4))), rep(0, 16), 0, 0, -1, 0, 0, 1, 0, 1, 0, -1, rep(0, 5), -1, 1, 0, 1, 0, -1, rep(0, 11)) #c(-10, 28, 0, 10, -1, rep(0, 3), -8 / 3, rep(0, 11), 1, rep(0, 4), -1, rep(0, 7))
> non_zero = c(1, 2, 3, 4, 5, 10, 15, 20, 39, 42, 44, 46, 52, 53, 55, 57)
> param_i = 1:4
> n.theta = 68
> n.sigma = N.l96
> q = rep(0.1, n.theta) #runif(n.theta)
> q[non_zero] = 0.9
> seq.Y = seq(2, N + 1, N / K)
> N = tail(seq.Y, 1)
> n.X = N.l96 * (N + 1)
> n.param = n.X + n.theta + n.sigma
> 
> n <- 5e4
> 
> 
> 
> X_total = euler_maruyama(rep(0, N.l96), del_t, N + burn_in, 8, diag(.5, N.l96)) # generating sample from Lorenz-63
> X = X_total[, (burn_in):(N + burn_in)]
> X = X[, 1:(N + 1)]
> Y = X[, seq(2, N + 1, N / K)] + rnorm(K, sd = sqrt(R)) # observations from Lorenz-63
> init = numeric(n.X + n.theta)
> 
> init[(n.X + 1):(n.X + n.theta)] <- rmvnorm(1, mu_truth + rnorm(n.theta, sd = 1.5), sigma = diag(1 / 50, n.theta)) #rmvnorm(1, c(10, 28, 8 / 3), sigma = diag(0.5, 3)) # random initial values for MCMC
> 
> 
> X.interp = X #matrix(-50,nrow = 3, ncol = N + 1)
> y.index = 1
> #X.interp[,1] = X[,1]
> for (i in seq(2, N + 1, N / K)) {
+     if (i == 2) {
+         X.interp[, 2] = Y[, 1]
+     } else {
+         for (j in 1:N.l96) {
+             X.interp[j, (i - N / K + 1):i] = seq(Y[j, y.index], Y[j, y.index + 1], (Y[j, y.index + 1] - Y[j, y.index]) * K / N)[-1]
+         }
+         y.index = y.index + 1
+     }
+ 
+ }
> 
> init[(1:n.X)] <- as.numeric(X.interp)
> 
> 
> sigma_Y = mean(diag(var(t(Y))))
> tau0 = sqrt(sigma_Y / (10 * K)) * 2
> tau1 = sqrt(sigma_Y * max((n.theta ^ 2.1) / (100 * K), log(K))) / 4
> 
> tau0 = sqrt(sigma_Y / (10 * K)) * 1.5
> tau1 = sqrt(sigma_Y * max((n.theta ^ 2.1) / (100 * K), log(K))) / 2
> 
> load('l96_linch_spike_5e2')
> var1 = cov(to_save[[1]][[1]][, 1:n.theta])
> scale_vec = 1.1 * sqrt(diag(var1))
> 
> scale = rep(n.theta)
> 
> scale = scale_vec # tf = 5 Sigma = 0.1  change of above
> scale[c(1)] = .4 * scale_vec[c(1)] ## Sigma = .5
> scale[c(2)] = 3.2 * scale_vec[c(2)]
> scale[c(3)] = 12 * scale_vec[c(3)]
> scale[c(4)] = 5.7 * scale_vec[c(4)]
> scale[c(5)] = 0.7 * scale_vec[c(5)]
> scale[ c(6)] = 3.5 * scale_vec[c(6)]
> scale[ c(14, 16)] = 3 * scale_vec[c(14, 16)]
> scale[ c(9, 13, 18, 62)] = 2.5 * scale_vec[c(9, 13, 18, 62)]
> scale[ c(10)] = 0.4 * scale_vec[c(10)]
> scale[ c(8, 12, 29, 32, 55)] = 0.5 * scale_vec[c(8, 12, 29, 32, 55)]
> scale[ c(67)] = 0.3 * scale_vec[c(67)]
> scale[ c(21, 24, 25, 26, 27, 28, 30, 31, 35, 65)] = 0.6 * scale_vec[c(21, 24, 25, 26, 27, 28, 30, 31, 35, 65)]
> scale[ c(17, 19)] = 2.5 * scale_vec[c(17, 19)]
> scale[ c(7, 20, 61, 64)] = 2 * scale_vec[c(7, 20, 61, 64)]
> scale[ c(23)] = 1.8 * scale_vec[c(23)]
> scale[ c(49, 52)] = 0.7 * scale_vec[c(49, 52)]
> scale[ c(40, 42, 43)] = 1.2 * scale_vec[c(40, 42, 43)]
> scale[ c(22, 37, 38, 41, 45, 46, 47, 48, 49, 50, 54, 56, 58, 59, 60, 61)] = 1.5 * scale_vec[c(22, 37, 38, 41, 45, 46, 47, 48, 49, 50, 54, 56, 58, 59, 60, 61)]
> scale[ c(11, 15, 39, 53, 66, 68)] = 0.8 * scale_vec[c(11, 15, 39, 53, 66, 68)]
> 
> scale.X = 0.0012
> 
> ans = linchpin(n, init)
[1] 10000
[1] 0.4686
       [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]   [,9]  [,10]
[1,] 0.3306 0.2698 0.3248 0.3638 0.3612 0.3260 0.3157 0.3035 0.3105 0.2885
[2,] 0.2919 0.3090 0.2650 0.2803 0.2702 0.2427 0.2700 0.3367 0.2643 0.2453
[3,] 0.3336 0.3465 0.3085 0.3267 0.3647 0.3132 0.3466 0.2848 0.3877 0.3412
[4,] 0.3072 0.3005 0.3134 0.3322 0.3191 0.3241 0.3424 0.3126 0.3117 0.3772
      [,11]  [,12]  [,13]  [,14]  [,15]  [,16]  [,17]
[1,] 0.3430 0.3265 0.2399 0.3618 0.3266 0.4288 0.3561
[2,] 0.3386 0.2677 0.2727 0.2715 0.2792 0.2816 0.3092
[3,] 0.3723 0.3448 0.3720 0.4546 0.2888 0.2513 0.3553
[4,] 0.3521 0.2899 0.3239 0.2979 0.3066 0.3481 0.3181
[1] 20000
[1] 0.45685
        [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]    [,9]
[1,] 0.32345 0.26550 0.31800 0.35915 0.35065 0.31540 0.30340 0.29415 0.30280
[2,] 0.28770 0.30175 0.25660 0.26675 0.26805 0.23835 0.26115 0.33225 0.25570
[3,] 0.32250 0.33040 0.29905 0.31535 0.35125 0.29905 0.33840 0.28140 0.37275
[4,] 0.29485 0.29025 0.31025 0.31940 0.31495 0.31425 0.32415 0.29835 0.30600
       [,10]   [,11]  [,12]   [,13]   [,14]   [,15]   [,16]  [,17]
[1,] 0.27855 0.33275 0.3275 0.23595 0.34800 0.31545 0.42625 0.3570
[2,] 0.23480 0.32725 0.2581 0.26520 0.26445 0.26615 0.27215 0.3016
[3,] 0.32535 0.36050 0.3324 0.35265 0.44265 0.28060 0.24930 0.3416
[4,] 0.37390 0.34030 0.2823 0.31475 0.29355 0.29895 0.33695 0.3060
[1] 30000
[1] 0.4537667
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
[1,] 0.3190667 0.2639333 0.3194000 0.3574000 0.3480333 0.3139667 0.2997667
[2,] 0.2892667 0.3038000 0.2576000 0.2652000 0.2701667 0.2398000 0.2626333
[3,] 0.3205667 0.3303667 0.2956000 0.3130000 0.3443000 0.2988000 0.3374000
[4,] 0.2885000 0.2853667 0.3083667 0.3137667 0.3105000 0.3121333 0.3176667
          [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14]
[1,] 0.2906667 0.3025667 0.2788667 0.3296333 0.3239000 0.2359000 0.3460667
[2,] 0.3331667 0.2614333 0.2351667 0.3288667 0.2598000 0.2655333 0.2688667
[3,] 0.2775000 0.3709667 0.3204333 0.3571667 0.3277000 0.3456667 0.4400333
[4,] 0.2963667 0.3058000 0.3694000 0.3347000 0.2760333 0.3080667 0.2919000
         [,15]     [,16]     [,17]
[1,] 0.3106000 0.4248667 0.3552333
[2,] 0.2693667 0.2738000 0.3010667
[3,] 0.2801667 0.2495000 0.3375333
[4,] 0.2943000 0.3342000 0.3005000
[1] 40000
[1] 0.448725
         [,1]     [,2]    [,3]     [,4]     [,5]     [,6]     [,7]     [,8]
[1,] 0.318425 0.262100 0.31785 0.356575 0.347450 0.312600 0.299675 0.289575
[2,] 0.286675 0.302800 0.25520 0.263350 0.267675 0.238300 0.259875 0.330400
[3,] 0.318675 0.327100 0.29280 0.310500 0.339725 0.296000 0.334975 0.274650
[4,] 0.288025 0.284625 0.30850 0.314075 0.309000 0.310375 0.317400 0.295300
         [,9]    [,10]    [,11]    [,12]    [,13]    [,14]    [,15]    [,16]
[1,] 0.300025 0.277625 0.327525 0.324675 0.237600 0.344925 0.312325 0.424875
[2,] 0.258900 0.233000 0.324725 0.256375 0.260825 0.266500 0.268325 0.271025
[3,] 0.370600 0.317750 0.355025 0.323750 0.342750 0.436400 0.275925 0.245350
[4,] 0.302700 0.366225 0.331025 0.276950 0.304600 0.290800 0.292625 0.331400
        [,17]
[1,] 0.351825
[2,] 0.300175
[3,] 0.334075
[4,] 0.298250
[1] 50000
[1] 0.44282
        [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]    [,9]
[1,] 0.31482 0.25818 0.31492 0.35268 0.34286 0.30900 0.29478 0.28396 0.29676
[2,] 0.28316 0.30022 0.25038 0.25940 0.26338 0.23416 0.25574 0.32698 0.25718
[3,] 0.31668 0.32794 0.29132 0.30934 0.33740 0.29400 0.33184 0.27368 0.36788
[4,] 0.28632 0.28400 0.30842 0.31158 0.30640 0.30832 0.31588 0.29064 0.30016
       [,10]   [,11]   [,12]   [,13]   [,14]   [,15]   [,16]   [,17]
[1,] 0.27470 0.32424 0.32084 0.23526 0.34172 0.30820 0.42132 0.34620
[2,] 0.23018 0.31934 0.25162 0.25648 0.26238 0.26406 0.26734 0.29586
[3,] 0.31592 0.35416 0.32412 0.34172 0.43272 0.27336 0.24324 0.33262
[4,] 0.36452 0.32972 0.27468 0.30466 0.28852 0.28758 0.32934 0.29568
> 
> chain_info = capture.output(cat("no of samples from MC is ", n, " \n starting from previous run ", "\n priors spike slab ", " time period ",
+                                 tf, " Sigma is .5"))
> 
> print(chain_info)
[1] "no of samples from MC is  50000  "                
[2] " starting from previous run  "                    
[3] " priors spike slab   time period  10  Sigma is .5"
> 
> attr = list('to' = to, 'tf' = tf, 'Nobs' = Nobs, 'N.l96' = N.l96, 'del_t' = del_t, 'a4' = a4, 'b4' = b4, 'tau0' = tau0, 'tau1' = tau1,
+             'K' = K, 'N' = N, 'burn_in' = burn_in, 'R' = R, 'inv_R' = inv_R, 'mu_truth' = mu_truth, 'non_zero' = non_zero, 'param_i' = param_i,
+             'n.X' = n.X, 'n.theta' = n.theta, 'n.sigma' = n.sigma, 'n.param' = n.param, 'q' = q, 'seq.Y' = seq.Y, 'n' = n, 'scale_vec' = scale_vec,
+             'scale' = scale, 'scale.X' = scale.X)
> 
> to_save = list(ans, chain_info)
> save(to_save,attr, file = "l96_5e5_cwise_spikes_interp_diffuse_init_theta_try")
> pm = ans[[1]][, 1:(n.sigma + n.theta)]
> 
> print(matrix(colMeans(pm), nrow = N.l96))
         [,1]         [,2]        [,3]        [,4]        [,5]        [,6]
[1,] 8.624304 -0.632082853  0.03589797  0.02446399 -0.07500734 -0.03288108
[2,] 6.277856  0.008914549 -0.92772798 -0.10959667 -0.13229607  0.01738916
[3,] 7.190650  0.011222300  0.06770602 -0.51964401  0.02769600  0.01105796
[4,] 6.355697  0.043850963 -0.01520415  0.02010008 -1.27528645  0.02192606
             [,7]         [,8]        [,9]         [,10]       [,11]
[1,] -0.014075584  0.003470475 0.010170507 -0.0193182750 -0.04531269
[2,]  0.008040873  0.032118772 0.018059193 -0.0003590307  1.00430368
[3,] -0.017646325 -0.053307345 0.002780383 -0.9804834592 -0.07487089
[4,]  0.032809266  0.025134873 0.070795844 -0.0393624638  1.00416080
            [,12]       [,13]       [,14]       [,15]       [,16]         [,17]
[1,] -0.001205132 -0.02237540  0.97651138 -0.98329955 -0.06589169 -0.0046493675
[2,] -0.979968309  0.02974277 -0.03675683  0.02160975  0.10002647 -0.0097347404
[3,]  0.031693394  0.03921588  0.94130655 -0.01589012 -0.04683131  0.0109353536
[4,] -0.040701926 -1.02345761  0.05452802 -0.04441908 -0.04612633 -0.0008116962
         [,18]
[1,] 0.5484331
[2,] 0.5530291
[3,] 0.5642079
[4,] 0.7179217
> 
> pm2 = ans[[1]][, (n.sigma + n.theta + 1):(n.sigma + 2 * n.theta)]
> print(matrix(colMeans(pm2), nrow = N.l96))
        [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]    [,9]
[1,] 0.99992 0.89152 0.01896 0.00850 0.01412 0.00372 0.00726 0.00546 0.00486
[2,] 0.99892 0.01578 0.97370 0.05460 0.05192 0.00804 0.00710 0.01534 0.01106
[3,] 0.99954 0.01106 0.02710 0.77996 0.01338 0.00548 0.00572 0.00484 0.00316
[4,] 1.00000 0.02214 0.01006 0.02914 1.00000 0.00612 0.00356 0.00646 0.00740
       [,10]   [,11]   [,12]   [,13]   [,14]   [,15]   [,16]   [,17]
[1,] 0.00480 0.00400 0.00622 0.00494 1.00000 0.99998 0.02004 0.00582
[2,] 0.00584 0.99958 0.99996 0.00608 0.00618 0.00538 0.04108 0.01632
[3,] 1.00000 0.00626 0.00554 0.00392 0.99956 0.00434 0.01770 0.00370
[4,] 0.00574 1.00000 0.00674 0.99860 0.00644 0.00578 0.02594 0.00892
> 
> proc.time()
     user    system   elapsed 
58305.582   520.132 59279.815 
